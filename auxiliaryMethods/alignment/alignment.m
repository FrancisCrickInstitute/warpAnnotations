function alignment(pathToUnalignedData, pathToAlignedDataset, debugFolder, debug)

planesInMemory = 128;
display(java.lang.Runtime.getRuntime.maxMemory)

%% Make sure we do not overwrite existing data
if exist(pathToAlignedDataset, 'dir')
    error(strcat(pathToAlignedDataset, 'exsists.'));
end
mkdir(pathToAlignedDataset);
wkwInit('new', pathToAlignedDataset, 32, 32, 'uint8', 1);
if ~exist(debugFolder, 'dir')
    mkdir(debugFolder);
end

%% Create parameter structures used for reading and writing wkw-files in matlab
outputDataset.backend = 'wkwrap';
outputDataset.root = pathToAlignedDataset;

% Find files in pathToUnalignedData, this currently assumes .dm3 file extension
fileList = dir(strcat(pathToUnalignedData, '*.dm3'));

% Suppress warnings generated by displaying images larger than screen
% resolution
warning('off');

for s=1:length(fileList)
    tic;
    % Read unaligned slice
    current_image = readDMFile(fullfile(pathToUnalignedData, fileList(s).name));
    current_image = padarray(current_image, [2000, 2000], 0, 'both');
    % Calculate features
    current_points  = detectSURFFeatures(current_image, 'MetricThreshold', 500, ...
        'NumOctaves', 3, 'ROI', [4001, 4001, size(current_image,2) - 8000, size(current_image,1) - 8000]);
    [current_features, current_valid_points]  = extractFeatures(current_image, current_points);
    if s == 1 
        % First slice will not be registred
        aligned_image = current_image;
        previous_image = aligned_image;
        previous_features = current_features;
        previous_valid_points = current_valid_points;
    else
        % All subsequent ones, aligned to previous image
        % Pairwise matching of features
        indexPairs = matchFeatures(previous_features, current_features, 'MatchThreshold', 50, 'MaxRatio', 0.8);
        previous_matched = previous_valid_points(indexPairs(:,1));
        current_matched = current_valid_points(indexPairs(:,2));
	% Use fallback (same alignment as previous plane) in case few matches or inliers
        if size(indexPairs,1) < 30
            display('TOO FEW MATCHED FEATURES');
            tform = previous_tform;
            current_inlier = 0;
	    previous_inlier = 0;
            save([debugFolder, 'broken_match', num2str(s, '%.4i'), '.mat'], '-regexp', '^(?!(result)$).');
	else
            [tform, current_inlier, previous_inlier] = estimateGeometricTransform( ...
                current_matched, previous_matched, 'similarity', ...
                'Confidence', 99.9, 'MaxDistance', 20, 'MaxNumTrials', 3000);
	    if length(current_inlier) < 10
                display('TOO FEW INLIER FEATURES');
		tform = previous_tform;
            	save([debugFolder, 'broken_inlier', num2str(s, '%.4i'), '.mat'], '-regexp', '^(?!(result)$).');
            end
        end
        outputView = imref2d(size(previous_image));
        aligned_image  = imwarp(current_image, tform, 'OutputView', outputView);
        if debug
            % Write figure showing all matched point pairs
            figure('visible','off');
            showMatchedFeatures(current_image, previous_image, previous_matched, current_matched);
            export_fig(strcat(debugFolder, 'matched_points', num2str(s, '%.4i'), '.png'));
            % Only inliers used for transformation
            figure('visible','off');
            showMatchedFeatures(current_image, previous_image, previous_inlier, current_inlier);
            export_fig(strcat(debugFolder, 'inlier_points', num2str(s, '%.4i'), '.png'));
            figure('visible','off');
            imshowpair(previous_image, aligned_image, 'diff')
            export_fig(strcat(debugFolder, 'montage', num2str(s, '%.4i'), '.png'));
            close all; 
        end
        % Recover translation, scale and angle inferred in alignment process
        Tinv  = tform.invert.T;
        tx = Tinv(3,1);
        ty = Tinv(3,2);
        ss = Tinv(2,1);
        sc = Tinv(1,1);
        scale_recovered = sqrt(ss*ss + sc*sc);
        theta_recovered = atan2(ss,sc)*180/pi;
        % Display progress to command line
        display(['Slice: ', num2str(s, '%.4i'), ' ---------------------------------']);
        display(['Extracted features: ', num2str(length(previous_valid_points)), ...
            ', ', num2str(length(current_valid_points))]);
        display(['Matched features: ', num2str(length(previous_matched)), ...
            ', ', num2str(length(current_matched))]);
        display(['Inlier features: ', num2str(length(previous_inlier)), ...
            ', ', num2str(length(current_inlier))]);
        display(['Translation: ', num2str(tx, '%.2f'), ', ', num2str(ty, '%.2f')]);
        display(['Rotation: ', num2str(theta_recovered, '%.2f')]);
        display(['Scale: ', num2str(scale_recovered, '%.2f')]);
        % Recalculate features on aligned images for next alignment step
        previous_image = aligned_image;
        previous_points  = detectSURFFeatures(previous_image, 'MetricThreshold', 500, ...
            'NumOctaves', 3, 'ROI', [4001, 4001, size(current_image,2) - 8000, size(current_image,1) - 8000]);
        [previous_features, previous_valid_points]  = extractFeatures(previous_image,  previous_points);
        previous_tform = tform;
    end
    toc;
    % Write aligned slice
    tic;
    if mod(s,planesInMemory) == 1
	result = zeros(size(aligned_image,1), size(aligned_image,2), planesInMemory, 'uint8');
	result(:,:,mod(s,planesInMemory)) = aligned_image; 
    elseif mod(s,planesInMemory) == 0
	result(:,:,planesInMemory) = aligned_image;
    	saveRawData(outputDataset, [1, 1, s-planesInMemory+1], result);
	clear result
    else
	result(:,:,mod(s,planesInMemory)) = aligned_image; 
    end
    toc;
end

end
